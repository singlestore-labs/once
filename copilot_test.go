package once

import (
	"runtime"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

// This file generated by Claude 3.7 Sonnet

func TestOnceSimple(t *testing.T) {
	t.Parallel()
	t.Log("Testing basic Once functionality - function should execute exactly once")
	
	var count int32
	o := New(func() {
		atomic.AddInt32(&count, 1)
	})
	
	// Call multiple times
	for i := 0; i < 5; i++ {
		t.Log("Calling Do(), iteration:", i+1)
		o.Do()
	}
	
	if got := atomic.LoadInt32(&count); got != 1 {
		t.Errorf("Expected function to execute once, got %d executions", got)
	}
}

func TestOnceConcurrent(t *testing.T) {
	t.Parallel()
	t.Log("Testing Once with concurrent goroutines - function should execute exactly once")
	
	var count int32
	o := New(func() {
		t.Log("Executing the function")
		// Sleep to increase chance of race conditions
		time.Sleep(10 * time.Millisecond)
		atomic.AddInt32(&count, 1)
	})
	
	// Launch multiple goroutines
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			t.Logf("Goroutine %d calling Do()", id)
			o.Do()
			t.Logf("Goroutine %d completed", id)
		}(i)
	}
	
	wg.Wait()
	
	if got := atomic.LoadInt32(&count); got != 1 {
		t.Errorf("Expected function to execute once, got %d executions", got)
	}
}

func TestOnceWithPanic(t *testing.T) {
	t.Parallel()
	t.Log("Testing Once when the function panics")
	
	var count int32
	o := New(func() {
		atomic.AddInt32(&count, 1)
		t.Log("Function is about to panic")
		panic("intentional panic")
	})
	
	// First call should panic
	func() {
		defer func() {
			if r := recover(); r != nil {
				t.Log("Panic recovered:", r)
			}
		}()
		o.Do()
	}()
	
	// Check that the function executed
	if got := atomic.LoadInt32(&count); got != 1 {
		t.Errorf("Expected function to execute once before panic, got %d executions", got)
	}
	
	// Second call should not execute the function
	func() {
		defer func() {
			if r := recover(); r != nil {
				t.Errorf("Unexpected panic on second call: %v", r)
			}
		}()
		t.Log("Calling Do() after panic")
		o.Do()
	}()
	
	// Count should still be 1
	if got := atomic.LoadInt32(&count); got != 1 {
		t.Errorf("Expected function to execute once, got %d executions", got)
	}
}

func TestMultipleOnceInstances(t *testing.T) {
	t.Parallel()
	t.Log("Testing multiple independent Once instances")
	
	var count1, count2 int32
	
	o1 := New(func() {
		t.Log("Executing function for o1")
		atomic.AddInt32(&count1, 1)
	})
	
	o2 := New(func() {
		t.Log("Executing function for o2")
		atomic.AddInt32(&count2, 1)
	})
	
	// Call each once multiple times
	for i := 0; i < 3; i++ {
		t.Logf("Iteration %d: calling o1.Do()", i+1)
		o1.Do()
		t.Logf("Iteration %d: calling o2.Do()", i+1)
		o2.Do()
	}
	
	if got := atomic.LoadInt32(&count1); got != 1 {
		t.Errorf("Expected o1 function to execute once, got %d executions", got)
	}
	
	if got := atomic.LoadInt32(&count2); got != 1 {
		t.Errorf("Expected o2 function to execute once, got %d executions", got)
	}
}

func TestOnceZeroValue(t *testing.T) {
	t.Parallel()
	t.Log("Testing Once with zero value (no explicit initialization)")
	
	// Create Once with zero value (no call to New())
	var o Once
	var executed bool
	
	// Set the function
	o.f = func() {
		t.Log("Executing function")
		executed = true
	}
	
	// Call Do on zero-value Once
	o.Do()
	
	if !executed {
		t.Error("Function should have executed with zero-value Once")
	}
}

func TestOnceWithRaceDetection(t *testing.T) {
	t.Parallel()
	t.Log("Testing Once with high concurrency to detect race conditions")
	
	var count int32
	o := New(func() {
		// Make this function take some time to increase race condition chances
		runtime.Gosched()
		time.Sleep(1 * time.Millisecond)
		atomic.AddInt32(&count, 1)
	})
	
	// Create a lot of goroutines to stress test
	const numGoroutines = 100
	var wg sync.WaitGroup
	
	// Use a channel to synchronize goroutines
	ready := make(chan struct{})
	
	// Create goroutines but don't start them yet
	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			
			// Wait for signal to start (increases likelihood of race conditions)
			<-ready
			
			t.Logf("Goroutine %d starting Do()", id)
			o.Do()
			t.Logf("Goroutine %d completed", id)
		}(i)
	}
	
	// Let all goroutines proceed at once
	close(ready)
	wg.Wait()
	
	if got := atomic.LoadInt32(&count); got != 1 {
		t.Errorf("Expected function to execute once, got %d executions", got)
	}
}

func TestOnceWithDeadlock(t *testing.T) {
	t.Parallel()
	t.Log("Testing Once for potential deadlock scenarios")
	
	// Create a channel to synchronize
	ch := make(chan struct{})
	
	// Create an Once with a function that depends on a channel
	o := New(func() {
		t.Log("Function waiting for channel")
		<-ch
		t.Log("Function completed")
	})
	
	// Start a goroutine that calls Do
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		o.Do()
	}()
	
	// Start another goroutine that also calls Do
	wg.Add(1)
	go func() {
		defer wg.Done()
		// Sleep a bit to ensure the first goroutine has called Do
		time.Sleep(10 * time.Millisecond)
		t.Log("Second goroutine calling Do()")
		o.Do()
		t.Log("Second goroutine completed")
	}()
	
	// Close the channel to allow the function to complete
	time.Sleep(20 * time.Millisecond)
	t.Log("Closing channel")
	close(ch)
	
	// Add timeout to prevent test hanging
	done := make(chan struct{})
	go func() {
		wg.Wait()
		close(done)
	}()
	
	select {
	case <-done:
		t.Log("Test completed successfully")
	case <-time.After(1 * time.Second):
		t.Fatal("Test timed out - possible deadlock")
	}
}

func TestModifyingFunctionAfterCreation(t *testing.T) {
	t.Parallel()
	t.Log("Testing behavior when modifying the function field after creation")
	
	var count1, count2 int32
	
	o := New(func() {
		t.Log("Original function executing")
		atomic.AddInt32(&count1, 1)
	})
	
	// Call once
	o.Do()
	
	// Change the function
	o.f = func() {
		t.Log("Modified function executing")
		atomic.AddInt32(&count2, 1)
	}
	
	// Call again
	o.Do()
	
	if got := atomic.LoadInt32(&count1); got != 1 {
		t.Errorf("Expected original function to execute once, got %d executions", got)
	}
	
	if got := atomic.LoadInt32(&count2); got != 0 {
		t.Errorf("Expected modified function not to execute, got %d executions", got)
	}
}

func TestNestedDoCalls(t *testing.T) {
	t.Parallel()
	t.Log("Testing behavior with nested Do calls")
	
	var outerCount, innerCount int32
	var innerOnce *Once
	
	outerOnce := New(func() {
		t.Log("Outer function executing")
		atomic.AddInt32(&outerCount, 1)
		
		// Create and call an inner Once
		innerOnce = New(func() {
			t.Log("Inner function executing")
			atomic.AddInt32(&innerCount, 1)
		})
		innerOnce.Do()
		
		// Call the inner Once again
		innerOnce.Do()
	})
	
	// Call the outer Once
	outerOnce.Do()
	
	// Call again
	outerOnce.Do()
	
	// Also call the inner one again
	if innerOnce != nil {
		innerOnce.Do()
	}
	
	if got := atomic.LoadInt32(&outerCount); got != 1 {
		t.Errorf("Expected outer function to execute once, got %d executions", got)
	}
	
	if got := atomic.LoadInt32(&innerCount); got != 1 {
		t.Errorf("Expected inner function to execute once, got %d executions", got)
	}
}
